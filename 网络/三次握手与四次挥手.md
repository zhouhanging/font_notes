## 三次握手
##### 第一次握手
浏览器向服务器发出连接请求报文段，报文首部的同步位SYN设为1，选择一个初始序号seq=x，然后客户端进入同步以发送状态。

第一次握手确认了浏览器的发送能力、服务端的接收能力。
##### 第二次握手
服务端收到建立连接请求报文后，同意建立连接，需要向客户端发送确认报文，报文首部的同步位SYN和确认位ACK都置1，确认号ack=x+1，也选择一个初始序号seq=y。这时服务端进入同步已确认状态。

第二次握手确认了浏览器和服务器的接收和发送的能力，但是服务器不确定浏览器的接收能力。
##### 第三次握手
客户端收到服务端的确认报文后，还需要向服务端发出一个确认报文，报文首部的确认位ACK置1，确认号ack=y+1，序号seq=x+1，客户端进入已建立连接状态，服务端收到确认报文后也进入已建立连接状态，这时候TCP连接建立成功。

TCP的标准规定，这次握手的ACK确认报文可以携带数据，但如果不携带数据则不会消耗序号，在这种情况下，下一个数据报文段的序号seq仍是x+1.

三次握手为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。具体来说就是，客户端发送了一个建立连接请求报文，但是这个报文段在网络的某个结点长时间滞留了，而客户端迟迟收不到确认，又重新发送了一个建立连接报文，这次成功建立TCP连接，搞完事之后，断开了连接。但是之前在网络结点滞留的那个建立连接请求报文来到服务端这边了，服务端收到之后，以为客户端又想建立连接，然后就向客户端发送确认报文段，同意建立连接，如果不采取三次握手的话，只要服务端发送确认之后，TCP连接就建立了。而客户端并没有想建立连接的想法，就没有理会这个确认报文，而服务端却一直在那苦苦等着客户端发来数据，这样服务端很多资源就这样白白浪费了。

## 四次挥手
##### 第一次挥手
客户端向服务端发送释放连接报文，并主动停止再发送数据，主动关闭TCP连接，这个连接释放报文首部的中止位FIN设置1，序号seq=x，这时客户端进入终止等待1状态。

##### 第二次挥手
服务端收到连接释放报文后，向客户端立即发出确认报文，报文首部的确认位ACK置1，确认号ack=x+1，序号seq=y，这时候服务端进入关闭等待状态。客户端收到确认报文后也进入终止等待2状态。

##### 第三次挥手
服务端已经没有要向客户端发送的数据了，然后就发送连接释放报文，报文首部的中止位FIN，确认位ACK都置1，确认号ack=x+1，序号seq=w。这时候服务端进入最后确认状态。

##### 第四次挥手
客户端收到服务端发过来的连接释放报文后，向服务端发送确认报文，报文首部的确认位ACK=1，确认号ack=w+1，序号seq=x+1，之后客户端进入时间等待状态


为什么客户端在第四次挥手会要等待2MSL的时间？为了防止发出的确认报文丢失，服务器收不到而导致服务器又重发了一次确认


[参考资料](https://leetcode-cn.com/circle/discuss/b4PW9S/)
